/******************************************************************************
*
* Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* Use of the Software is limited solely to applications:
* (a) running on a Xilinx device, or
* (b) that interact with a Xilinx device through a bus or interconnect.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* Except as contained in this notice, the name of the Xilinx shall not be used
* in advertising or otherwise to promote the sale, use or other dealings in
* this Software without prior written authorization from Xilinx.
*
******************************************************************************/

/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include "audio.h"
#include "intc.h"
#include "userio.h"
#include "fifo.h"



/******************************************************************************
 * Function to write one byte (8-bits) to one of the registers from the audio
 * controller.
 *
 * @param	u8RegAddr is the LSB part of the register address (0x40xx).
 * @param	u8Data is the data byte to write.
 *
 * @return	XST_SUCCESS if all the bytes have been sent to Controller.
 * 			XST_FAILURE otherwise.
 *****************************************************************************/
XStatus fnAudioWriteToReg(u8 u8RegAddr, u16 u8Data) {

	u8 u8TxData[2];
	u8 u8BytesSent;

	u8TxData[0] = u8RegAddr << 1;
	u8TxData[0] = u8TxData[0] | ((u8Data>>8) & 0b1);

	u8TxData[1] = u8Data & 0xFF;

	u8BytesSent = XIic_Send(XPAR_IIC_0_BASEADDR, IIC_SLAVE_ADDR, u8TxData, 2, XIIC_STOP	);

	while( XIic_CheckIsBusBusy(XPAR_IIC_0_BASEADDR));

	//check if all the bytes where sent
	if (u8BytesSent != 2)
	{
		return XST_FAILURE;
	}

	return XST_SUCCESS;
}

/******************************************************************************
 * Function to read one byte (8-bits) from the register space of audio controller.
 *
 * @param	u8RegAddr is the LSB part of the register address (0x40xx).
 * @param	u8RxData is the returned value
 *
 * @return	XST_SUCCESS if the desired number of bytes have been read from the controller
 * 			XST_FAILURE otherwise
 *****************************************************************************/
XStatus fnAudioReadFromReg(u8 u8RegAddr, u16 *u16RxData) {

	u8 u8TxData[1];
	u8 u8RxData[2];
	u8 u8BytesSent, u8BytesReceived;

	u8TxData[0] = u8RegAddr<<1;


	u8BytesSent = XIic_Send(XPAR_IIC_0_BASEADDR, IIC_SLAVE_ADDR, u8TxData, 1, XIIC_REPEATED_START);
	//check if all the bytes where sent
	if (u8BytesSent != 1)
	{
		return XST_FAILURE;
	}

	u8BytesReceived = XIic_Recv(XPAR_IIC_0_BASEADDR, IIC_SLAVE_ADDR, u8RxData, 2, XIIC_STOP);
	//check if there are missing bytes
	if (u8BytesReceived != 2)
	{
		return XST_FAILURE;
	}

	*u16RxData= (u16)( (u8RxData[1] << 8) | u8RxData[0] );

	return XST_SUCCESS;

}



/******************************************************************************
 * Configure the initial settings of the audio controller, the majority of
 * these will remain unchanged during the normal functioning of the code.
 * In order to generate a correct BCLK and LRCK, which are crucial for the
 * correct operating of the controller, the sampling rate must me set in the
 * I2S_TRANSFER_CONTROL_REG. The sampling rate options are:
 *    "000" -  8 KHz
 *    "001" - 12 KHz
 *    "010" - 16 KHz
 *    "011" - 24 KHz
 *    "100" - 32 KHz
 *    "101" - 48 KHz
 *    "110" - 96 KHz
 * These options are valid only if the I2S controller is in slave mode.
 * When In master mode the ADAU will generate the appropriate BCLK and LRCLK
 * internally, and the sampling rates which will be set in the I2S_TRANSFER_CONTROL_REG
 * are ignored.
 *
 * @param	none.
 *
 * @return	XST_SUCCESS if the configuration is successful
 *****************************************************************************/
XStatus fnAudioStartupConfig ()
{

	static u16 u8RxData;

	int Status;
	Status = XST_SUCCESS;


	//slave: I2S
	Status = fnAudioWriteToReg(R15_SOFTWARE_RESET, 0b000000000);

	if (Status == XST_FAILURE)
	{
		if (Demo.u8Verbose)
		{
			xil_printf("\r\nError: could not write R15_SOFTWARE_RESET (0x00)");
		}
		return XST_FAILURE;
	}
	usleep(1000000);


	Status =fnAudioWriteToReg (R6_POWER_MGMT, 0b000110000 ) ; //Power Up
	if (Status == XST_FAILURE)
		{
			if (Demo.u8Verbose)
			{
				xil_printf("\r\nError: could not write R0_LEFT_ADC_VOL (0b000010111)");
			}
			return XST_FAILURE;
		}
	Status = fnAudioWriteToReg(R0_LEFT_ADC_VOL, 0b000010111);
	if (Status == XST_FAILURE)
	{
		if (Demo.u8Verbose)
		{
			xil_printf("\r\nError: could not write R0_LEFT_ADC_VOL (0b000010111)");
		}
		return XST_FAILURE;
	}
	Status = fnAudioWriteToReg(R1_RIGHT_ADC_VOL, 0b000010111);
	if (Status == XST_FAILURE)
	{
		if (Demo.u8Verbose)
		{
			xil_printf("\r\nError: could not write R0_LEFT_ADC_VOL (0b000010111)");
		}
		return XST_FAILURE;
	}
	Status = fnAudioWriteToReg(R2_LEFT_DAC_VOL,0b001111001);
	if (Status == XST_FAILURE)
	{
		if (Demo.u8Verbose)
		{
			xil_printf("\r\nError: could not write R0_LEFT_ADC_VOL (0b000010111)");
		}
		return XST_FAILURE;
	}
	Status = fnAudioWriteToReg(R3_RIGHT_DAC_VOL, 0b001111001);
	if (Status == XST_FAILURE)
	{
		if (Demo.u8Verbose)
		{
			xil_printf("\r\nError: could not write R0_LEFT_ADC_VOL (0b000010111)");
		}
		return XST_FAILURE;
	}
	Status = fnAudioWriteToReg(R4_ANALOG_PATH, 0b000010010 );//ALLOW MIXED DAC , MUTE MIC
	if (Status == XST_FAILURE)
	{
		if (Demo.u8Verbose)
		{
			xil_printf("\r\nError: could not write R0_LEFT_ADC_VOL (0b000010111)");
		}
		return XST_FAILURE;
	}
	fnAudioWriteToReg(R5_DIGITAL_PATH, 0b000000111);// 48 kHz Sampling Rate emphasis , no hp
	fnAudioWriteToReg(R7_DIGITAL_IF, 0b000001110);//32 bits word and i2s slave
	fnAudioWriteToReg(R8_SAMPLE_RATE, 0b000000000);//SR[3:0]=0000
	usleep(1000000);
	fnAudioWriteToReg(R9_ACTIVE, 0b000000001);
	usleep(1000000);
	fnAudioWriteToReg(R6_POWER_MGMT, 0b000100010);//Output Power Up

	fnAudioReadFromReg(R7_DIGITAL_IF,&u8RxData);
	xil_printf("\r\n Read %x",u8RxData);
	usleep(90000);

	return XST_SUCCESS;
}


/******************************************************************************
 * Initialize PLL and Audio controller over the I2C bus
 *
 * @param	none
 *
 * @return	none.
 *****************************************************************************/
XStatus fnInitAudio()
{
	int Status;

	//Set the PLL and wait for Lock
	//Status = fnAudioPllConfig();
//	if (Status != XST_SUCCESS)
//	{
//		if (Demo.u8Verbose)
//		{
//			xil_printf("\r\nError: Could not lock PLL");
//		}
//	}

	//Configure the ADAU registers
	Status = fnAudioStartupConfig();
	if (Status != XST_SUCCESS)
	{
		if (Demo.u8Verbose)
		{
			xil_printf("\r\nError: Failed I2C Configuration");
		}
	}


	return XST_SUCCESS;
}

u32 SourceBuffer[MAX_DATA_BUFFER_SIZE * WORD_SIZE];
static u32  DestinationBuffer[MAX_DATA_BUFFER_SIZE * WORD_SIZE];
/*****************************************************************************/
				/**
				*
				* This is the Pulling handler callback function.
				*
				* @param	InstancePtr is a reference to the Fifo device instance.
				*
				* @return	None.
				*
				* @note		None.
				*
				******************************************************************************/
				 void FifoPullingHandler(XLlFifo *InstancePtr)
				{
					  //FIFO READ
					    int i,j;

					    u32 RxWord;
					    static u32 ReceiveLength;




					while((XLlFifo_iRxOccupancy(InstancePtr))) {

					 						/* Read Receive Length */
					 				ReceiveLength = (XLlFifo_iRxGetLen(InstancePtr))/WORD_SIZE;
					 			for (i=0; i < ReceiveLength; i++) {
					 						RxWord = XLlFifo_RxGetWord(InstancePtr);
					 				*(DestinationBuffer+i) = RxWord;

					 			}

					 			/* Fill the transmit buffer with incremental pattern */
					 			for (i=0;i<ReceiveLength;i++)
					 			*(SourceBuffer + i) = *(DestinationBuffer+i);


					 					/* Writing into the FIFO Transmit Port Buffer */
					 					for (j=0 ; j < MAX_PACKET_LEN ; j++){
					 						if( XLlFifo_iTxVacancy(InstancePtr) ){
					 							XLlFifo_TxPutWord(InstancePtr,
					 								*(SourceBuffer+(MAX_PACKET_LEN)+j));
					 						}
					 					}



					 				/* Start Transmission by writing transmission length into the TLR */
					 				XLlFifo_iTxSetLen(InstancePtr, (MAX_DATA_BUFFER_SIZE * WORD_SIZE));


					 				/* Check for Transmission completion */
					 				while( !(XLlFifo_IsTxDone(InstancePtr)) ){

					 				}


					}



				}




/************************** Variable Definitions *****************************/
/*
 * The following are declared globally so they are zeroed and so they are
 * easily accessible from a debugger
 */
static XIic sIic;

static XGpio sUserIO;

static XLlFifo fifo;

#ifdef XPAR_INTC_0_DEVICE_ID
 static XIntc sIntc;
#else
 static XScuGic sIntc;
#endif

//
// Interrupt vector table

const ivt_t ivt[] = {
	//IIC
	{XPAR_INTC_0_IIC_0_VEC_ID, (XInterruptHandler)XIic_InterruptHandler, &sIic},
	//GPIO
	{XPAR_INTC_0_GPIO_0_VEC_ID, (XInterruptHandler)fnUserIOIsr, &sUserIO},
	//FIFO
	{XPAR_INTC_0_LLFIFO_0_VEC_ID, (XInterruptHandler)fnPollingIsr, &fifo},
};


static volatile u32 IntrFlag; /* Interrupt Handler Flag */







int main()
{
	init_platform();

    print("Program stars.. \n\r");

    int Status;

    	Demo.u8Verbose = 0;

    	Xil_DCacheDisable();

    	xil_printf("\r\n--- Entering main() 2--- \r\n");

    	//Initialize FIFO
    	   	Status = fnInitFifo(&fifo,FIFO_DEV_ID);
    	    		    	    	if(Status != XST_SUCCESS) {
    	    		    	    		xil_printf("Error initializing fifo");
    	    		    	    		return XST_FAILURE;
    	    		    	    	}
    	//
    	//Initialize the interrupt controller
    	Status = fnInitInterruptController(&sIntc);
    	if(Status != XST_SUCCESS) {
    		xil_printf("Error initializing interrupts");
    		return XST_FAILURE;
    	}




    	// Initialize IIC controller
    	Status = fnInitIic(&sIic);
    	if(Status != XST_SUCCESS) {
    		xil_printf("Error initializing I2C controller");
    		return XST_FAILURE;
    	}



    	// Initialize User I/O driver
    	    Status = fnInitUserIO(&sUserIO);
    	    if(Status != XST_SUCCESS) {
    	    	xil_printf("User I/O ERROR");
    	    	return XST_FAILURE;
    	    }


    	Status = fnInitAudio();
    	    	if(Status != XST_SUCCESS) {
    	    	    		xil_printf("Error initializing I2C controller");
    	    	    		return XST_FAILURE;
    	    	    	}


    		xil_printf("\r\n--- Setup Audio done --- \r\n");


   // Enable all interrupts in our interrupt vector table
   	// Make sure all driver instances using interrupts are initialized first
      		fnEnableInterrupts(&sIntc, &ivt[0], sizeof(ivt)/sizeof(ivt[0]));
      		/* Enable the interrupt for the FIFO*/
      	XLlFifo_IntEnable(&fifo, XLLF_INT_RFPF_MASK | XLLF_INT_RFPE_MASK );//Enable FIFO RX empty and full interrupts




while(1){
	// Checking the SW change event
			if(Demo.fUserIOEvent) {

				xil_printf("\r\n--- LED STATES CHANGE!--- \r\n");

				XGpio_DiscreteWrite(&sUserIO,LED_CHANNEL,Demo.chSw);


				//XLlFifo_Reset(&fifo);

				// Reset the user I/O flag
				Demo.chSw = 0;
				Demo.fUserIOEvent = 0;
			}

			if(Demo.fifoRxFull){
				xil_printf("\r\n--- FifoPullingHandler!--- \r\n");
				FifoPullingHandler(&fifo);
		      	XLlFifo_IntEnable(&fifo, XLLF_INT_RFPF_MASK | XLLF_INT_RFPE_MASK);//Enable FIFO RX empty and full interrupts


			}


	}
cleanup_platform();
return 0;
}
