//
// Based on https://github.com/xupgit/High-Level-Synthesis-Flow-on-Zynq-using-Vivado-HLS/blob/master/Lab4.md
//
// Modified by Sergio Lopez-Buedo, january 2020
//

#include "../fir_filter/fir_filter.h"

// order of filter
#define N 255

// two samples, one for left channel and the other for right channel
void fir_filter(data_t *datain, data_t *dataout) {

  const coef_t c[N+1] = {
		  0.0010028,0.00088008,0.00049318,-1.6039e-05,
		  -0.00047555,-0.0007431,-0.00075236,-0.0005296,-0.00017657,0.00017241,
		  0.00040201,0.00045631,0.00035321,0.00016877,-8.4031e-07,-8.3275e-05,-6.118e-05,
		  2.2662e-05,8.8471e-05,6.112e-05,-8.793e-05,-0.00031771,-0.00052619,-0.00058959,-0.00041875,
		  -9.4567e-06,0.00053611,0.0010306,0.0012629,0.0010806,0.00046269,-0.00044794,-0.0013708,-0.0019717,
		  -0.0019797,-0.0012973,-6.18e-05,0.0013718,0.0025296,0.0029725,0.002457,0.0010447,
		  -0.00088472,-0.0027298,-0.003853,-0.0037977,-0.0024637,-0.00017652,0.0023836,0.0043815,
		  0.0050976,0.0041819,0.001804,-0.0013621,-0.0043252,-0.0060852,-0.0059689,-0.0038787,
		  -0.00036686,0.0035042,0.0064816,0.0075261,0.0061713,0.0027147,-0.0018354,-0.0060502,
		  -0.0085295,-0.0083647,-0.0054663,-0.00063687,0.0046464,0.0086825,0.010095,0.0082977,
		  0.0037269,-0.0022569,-0.0077714,-0.011006,-0.010814,-0.007119,-0.00097876,0.0057125,
		  0.01081,0.012605,0.010401,0.0047707,-0.0025832,
		  -0.0093436,-0.013311,-0.01312,-0.0087073,-0.0013721,0.0066072,0.012681,0.014846,0.012306,
		  0.0057619,-0.0027812,-0.010627,-0.015244,-0.015081,-0.010094,-0.001785,0.0072487,0.014128,
		  0.016616,0.013842,0.0066117,-0.0028325,-0.011505,-0.016627,-0.016519,-0.011151,-0.0021777,
		  0.0075795,0.015019,0.01775,0.014864,0.0072374,-0.0027361,-0.011899,-0.017333,-0.017295,
		  -0.011775,-0.0025078,0.0075732,0.015271,0.018141,0.015271,0.0075732,-0.0025078,-0.011775,
		  -0.017295,
		  -0.017333,-0.011899,-0.0027361,0.0072374,0.014864,0.01775,0.015019,0.0075795,-0.0021777,
		  -0.011151,-0.016519,-0.016627,-0.011505,-0.0028325,0.0066117,0.013842,0.016616,0.014128,0.0072487,-0.001785,-0.010094,-0.015081,-0.015244,-0.010627,-0.0027812,0.0057619,0.012306,0.014846,0.012681,0.0066072,-0.0013721,-0.0087073,-0.01312,-0.013311,-0.0093436,-0.0025832,0.0047707,0.010401,0.012605,0.01081,0.0057125,
		  -0.00097876,-0.007119,-0.010814,-0.011006,-0.0077714,-0.0022569,0.0037269,0.0082977,0.010095,
		  0.0086825,0.0046464,-0.00063687,-0.0054663,-0.0083647,-0.0085295,-0.0060502,-0.0018354,0.0027147,0.0061713,0.0075261,0.0064816,0.0035042,-0.00036686,-0.0038787,-0.0059689,-0.0060852,-0.0043252,-0.0013621,0.001804,0.0041819,0.0050976,0.0043815,0.0023836,-0.00017652,-0.0024637,-0.0037977,-0.003853,-0.0027298,
		  -0.00088472,0.0010447,0.002457,0.0029725,0.0025296,0.0013718,-6.18e-05,-0.0012973,-0.0019797,-0.0019717,-0.0013708,-0.00044794,0.00046269,0.0010806,0.0012629,0.0010306,0.00053611,-9.4567e-06,-0.00041875,-0.00058959,-0.00052619,-0.00031771,-8.793e-05,6.112e-05,8.8471e-05,2.2662e-05,-6.118e-05,-8.3275e-05,-8.4031e-07,0.00016877,
		  0.00035321,0.00045631,0.00040201,0.00017241,-0.00017657,-0.0005296,-0.00075236,-0.0007431,-0.00047555,-1.6039e-05,0.00049318,0.00088008,0.0010028

  };

  // note that the shift registers for the FIR filters have been declared
  // as static to maintain values between successive function calls
  static data_t shift_reg_left[N];
  static data_t shift_reg_right[N];

  // accumulators
  acc_t acc_left;
  acc_t acc_right;

  // index for the loops
  int i;

  //////////////////
  // Left Channel //
  //////////////////
  // last tap
  acc_left = (acc_t) shift_reg_left[N-1] * (acc_t) c[N];

  // middle taps
  loop_left: for (i=N-1; i!=0; i--) {
    acc_left += (acc_t) shift_reg_left[i-1] * (acc_t) c[i];
    shift_reg_left[i] = shift_reg_left[i-1];
  }

  // first tap
  acc_left += (acc_t) datain[0] * (acc_t) c[0];
  shift_reg_left[0] = datain[0];

  // output result
  //dataout[0] = acc_left / 32768;
  dataout[0] = acc_left ;
  ///////////////////
  // Right Channel //
  ///////////////////

  // last tap
  acc_right = (acc_t) shift_reg_right[N-1] * (acc_t) c[N];

  // middle taps
  loop_right: for (i=N-1; i!=0; i--) {
    acc_right += (acc_t) shift_reg_right[i-1] * (acc_t) c[i];
    shift_reg_right[i] = shift_reg_right[i-1];
  }

  // first tap
  acc_right += (acc_t) datain[1]* (acc_t) c[0];
  shift_reg_right[0] = datain[1];

  // output result
  //dataout[1] = acc_right / 32768;
  dataout[1] = acc_left;
}
